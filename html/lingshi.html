<!-- <!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <div id="demo"></div>
  <input type="button" value="点击" onclick="add()">
  <script>
    // let demo = document.getElementById('demo')

    // let add = (function () {
    //   let conter = 0
    //   return function () {
    //     conter += 1
    //     demo.innerHTML = conter
    //   }
    // })()


    // function counter() {
    //   var n = 0;
    //   return function () {
    //     console.log(n += 1)
    //   }
    // }
    // counter()()

    // function counter(n) { //属性存储器结构，内部没有定义局部变量，通过参数保存私有状态 
    //   return { //嵌套函数只有一个count(); 
    //     get count() { //在getter方法下 
    //       return console.log(n++); //传入参数（私有状态）自++
    //     },
    //     set count(m) { //在setter方法下 
    //       if (m >= n) n = m; //传入参数于等于当前状态，n=m并返回； 
    //       else throw Error("error") //否则就报错。 
    //     }
    //   }
    // };
    // var c = counter(1000);
    // console.log(c)
    // c.count; //1000 
    // c.count; //1001 
    // c.count = 2000;
    // c.count; //2000 
    // c.count = 2000; //报错
  </script>
</body>
</html> -->


<!-- <head>
  <title></title>
  <style type="text/css">
    #p {
      width: 300px;
      height: 300px;
      padding: 10px;
      border: 1px solid black;
    }

    #c {
      width: 100px;
      height: 100px;
      border: 1px solid red;
    }
  </style>
</head>
<body>
  <div id="p">
    parent
    <div id="c">
      child
    </div>
  </div>
  <script type="text/javascript">
    var p = document.getElementById('p'),
      c = document.getElementById('c');
    c.addEventListener('click', function () {
      alert('子节点捕获')
    }, true);

    c.addEventListener('click', function () {
      alert('子节点冒泡')
    }, false);

    p.addEventListener('click', function () {
      alert('父节点捕获')
    }, true);

    p.addEventListener('click', function () {
      alert('父节点冒泡')
    }, false);
  </script>
</body> -->

<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <style>
    .box {
      width: 0;
      height: 0;
      border-radius: 50%;
      border: 50px solid red;
      border-bottom-color: rebeccapurple;
      border-top-color: red;
      border-left-color: blue;
      border-right-color: pink;

    }

    
  </style>
</head>

<body>
  <div class="box"></div>
  <script>
    // function Person() {
    //   this.name = 'liuzuan';
    //   this.sex = 'male';
    //   this.age = 25;

    // }
    // Person.prototype.toString = function() {
    //   return '(' + this.name + this.sex + this.age + ')'
    // }
    // var person1 = new Person();
    // console.log(person1)

    // function Point(x, y) {
    //   this.x = x;
    //   this.y = y;
    // }
    // Point.prototype.toString = function () {
    //   return '(' + this.x + ', ' + this.y +
    //     ')';
    // };
    // var p = new Point(1, 2);
    // console.log(p.toString())


    function Person() {}
    console.log(Person.prototype.constructor === Person); // true 
    var p1 = new Person();
    //使用instanceof 操作符可以判断一个对象的类型。
    //typeof一般用来获取简单类型和函数。而引用类型一般使用instanceof，因为引用类型用typeof 总是返回object。 
    console.log(p1 instanceof Person); // true
  </script>
</body>

</html>